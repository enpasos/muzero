/*
 *  Copyright (c) 2021 enpasos GmbH
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

package ai.enpasos.muzero.tictactoe.run.exploitability;

import ai.enpasos.muzero.platform.agent.a_loopcontrol.Action;
import ai.enpasos.muzero.platform.agent.e_experience.ZeroSumGame;
import ai.enpasos.muzero.platform.common.MuZeroException;
import ai.enpasos.muzero.platform.environment.OneOfTwoPlayer;
import ai.enpasos.muzero.tictactoe.config.TicTacToeGame;
import lombok.Data;
import org.apache.commons.lang3.ArrayUtils;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.*;
import java.util.stream.IntStream;

import static ai.enpasos.muzero.platform.common.Functions.dotProduct;

@Data
public class DNode {
    ZeroSumGame game;
    boolean terminal;
    DNode parent;
    List<DNode> children;

    @Nullable DNode aiChosenChild;

    boolean decisionMatters;

    double[] optimalPolicy;
    double[] modelPolicy;
    double[] bestResponsePolicy;


    Integer bestForceableValuePlayerA;
    Integer bestForceableValuePlayerB;

    double bestExploitableValuePlayerA;
    double bestExploitableValuePlayerB;


    public DNode(ZeroSumGame game, int actionSpaceSize) {
        this.game = game;
        children = new ArrayList<>();
        terminal = false;
        optimalPolicy = new double[actionSpaceSize];
        modelPolicy = new double[actionSpaceSize];
        bestResponsePolicy = new double[actionSpaceSize];
    }

    public DNode(DNode parent, ZeroSumGame game, int actionSpaceSize) {
        this(game, actionSpaceSize);
        this.parent = parent;
    }

    public @Nullable Integer getBestForceableValue(@NotNull OneOfTwoPlayer player) {
        switch (player) {
            case PLAYER_A:
                return bestForceableValuePlayerA;
            case PLAYER_B:
                return bestForceableValuePlayerB;
            default:
                return null;
        }
    }

    public @Nullable double getBestExploitableValue(@NotNull OneOfTwoPlayer player) {
        switch (player) {
            case PLAYER_A:
                return bestExploitableValuePlayerA;
            case PLAYER_B:
                return bestExploitableValuePlayerB;
            default:
                return 0;
        }
    }

    public void setBestExploitableValue(@NotNull OneOfTwoPlayer player, double value) {
        if (player == OneOfTwoPlayer.PLAYER_A) {
            bestExploitableValuePlayerA = value;
        } else {
            bestExploitableValuePlayerB = value;
        }
    }

    public void setBestForceableValue(@NotNull OneOfTwoPlayer player, Integer value) {
        if (player == OneOfTwoPlayer.PLAYER_A) {
            bestForceableValuePlayerA = value;
        } else {
            bestForceableValuePlayerB = value;
        }
    }


    public void findNodesWhereADecisionMatters(@NotNull OneOfTwoPlayer player, @NotNull Set<DNode> nodesWhereADecisionMatters) {

        for (DNode child : children) {
            child.findNodesWhereADecisionMatters(player, nodesWhereADecisionMatters);
        }
        if (this.game.toPlay() == player && this.getChildren().size() > 1 && this.getChildren().stream().mapToInt(n -> n.getBestForceableValue(player)).distinct().count() > 1) {
            nodesWhereADecisionMatters.add(this);
            decisionMatters = true;
        } else {
            decisionMatters = false;
        }

    }


    public Integer getValue(OneOfTwoPlayer playerPerspective) {
        int value;
        OneOfTwoPlayer opponent = OneOfTwoPlayer.otherPlayer(playerPerspective);
        if (this.game.getEnvironment().hasPlayerWon(playerPerspective)) {
            value = 1;
        } else if (this.game.getEnvironment().hasPlayerWon(opponent)) {
            value = -1;
        } else {
            value = 0;
        }
        return value;
    }


    public void expand(@NotNull List<DNode> nonExpandedGameNodes, @NotNull List<DNode> terminalGameNodes) {
        if (!game.terminal() && !game.legalActions().isEmpty()) {
            for (Action action : game.legalActions()) {
                ZeroSumGame newGame = (ZeroSumGame) game.copy();
                newGame.apply(action);
                DNode child = new DNode(this, newGame, this.modelPolicy.length);
                this.children.add(child);
                nonExpandedGameNodes.add(child);
            }
        } else {
            terminalGameNodes.add(this);
            terminal = true;
        }
        nonExpandedGameNodes.remove(this);
    }


    public void collectNonTerminalNodes(@NotNull Set<DNode> nonTerminalNodes) {
        if (!this.children.isEmpty()) {
            nonTerminalNodes.add(this);
            this.children.forEach(n -> n.collectNonTerminalNodes(nonTerminalNodes));
        }
    }


    public int hashCode() {
        return Arrays.deepHashCode(game.getEnvironment().getBoard());
    }

    /**
     * Two nodes are equal if they have the same state.
     * Here we are switching implicitly from tree to acyclic graph.
     * Comparison has an acyclic directed graph in mind.
     */
    public boolean equals(Object o) {
        if (!(o instanceof DNode n)) return false;

        return Arrays.deepEquals(
            n.game.getEnvironment().getBoard(),
            game.getEnvironment().getBoard());

    }


    public void propagateBestForceableValueUp(@NotNull OneOfTwoPlayer player) {
        for (DNode n : this.children) {
            if (n.getBestForceableValue(player) == null) {
                n.propagateBestForceableValueUp(player);
            }
        }
        if (this.getBestForceableValue(player) == null) {
            if (this.game.toPlay() == player) {
                // the player decides -> max
                this.setBestForceableValue(player, this.children.stream().
                    max(Comparator.comparing(n -> n.getBestForceableValue(player)))
                    .orElseThrow(MuZeroException::new).getBestForceableValue(player));
            } else {
                // the opponent decides -> min
                this.setBestForceableValue(player, this.children.stream().
                    min(Comparator.comparing(n -> n.getBestForceableValue(player)))
                    .orElseThrow(MuZeroException::new).getBestForceableValue(player));
            }
        }
    }

    public int getAction() {
        return this.game.getEpisodeDO().getAction();
    }

    public void propagateBestExploitableValueUp(@NotNull OneOfTwoPlayer exploiter) {
        for (DNode n : this.children) {
            n.propagateBestExploitableValueUp(exploiter);
        }
        if (this.isLeaf())  {
            this.setBestExploitableValue(exploiter, this.getValue(exploiter));
        } else {
            if (this.getActions().equals(List.of(1,7,3,6,8,2,4))) {
                int i = 42;
            }




            if (this.game.toPlay() == exploiter) {
                // the exploiter decides -> max
                DNode exploitedSubnode = this.children.stream().
                        max(Comparator.comparing(n -> n.getBestExploitableValue(exploiter)))
                        .orElseThrow(MuZeroException::new);
                double exploitableValue = exploitedSubnode.getBestExploitableValue(exploiter);
                this.setBestExploitableValue(exploiter, exploitableValue);
                // from here one could also set the exploiting policy
                this.bestResponsePolicy = new double[this.modelPolicy.length];
                this.bestResponsePolicy[exploitedSubnode.getAction()] = 1.0;
//                if (exploitableValue > 0 && this.game.getEpisodeDO().getActions().size() < 5) {
//                    System.out.println("exploitableValue = " + exploitableValue + " at " + this.game.getEpisodeDO().getActions());
//                }

            } else {
                // the player decides according to its model policy
                double[] exploitableValues = new double[this.modelPolicy.length];
                this.children.stream().forEach(n -> {
                    int a = n.getAction();
                    exploitableValues[a] = n.getBestExploitableValue(exploiter);
                });
                double exploitableValue = dotProduct(modelPolicy, exploitableValues);
                this.setBestExploitableValue(exploiter, exploitableValue);
            }
        }
    }

//    public DNode getChild(int action) {
//        for (DNode n : children) {
//            int t = n.game.getEpisodeDO().getLastTimeWithAction();
//            if (n.game.getEpisodeDO().getTimeSteps().get(t).getAction() == action) {
//                return n;
//            }
//        }
//        return null;
//    }

    public  boolean isOnOptimalPath(DNode root) {
        return this.bestForceableValuePlayerA.equals(root.bestForceableValuePlayerA)
            && this.bestForceableValuePlayerB.equals(root.bestForceableValuePlayerB);
    }

    public void propagateOptimalPolicyUp() {
        for (DNode n : this.children) {
            n.propagateOptimalPolicyUp();
        }
        if (!isLeaf()) {

            double v = getBestForceableValue((OneOfTwoPlayer) game.toPlay());

            int count = (int) this.children.stream().filter(n -> n.getBestForceableValue((OneOfTwoPlayer) game.toPlay()) == v).count();

            Arrays.fill(this.optimalPolicy, 0);

            this.children.stream().filter(n -> n.getBestForceableValue((OneOfTwoPlayer) game.toPlay()) == v)
                    .forEach(n -> {
                        int a = n.getAction();
                        this.optimalPolicy[a] = 1.0 / count;
                    });


        }
    }

    public void collectAllNodes(Set< DNode> nodes, boolean withLeafs) {
        if (!this.isLeaf() || withLeafs) {
            nodes.add( this);
        }

        if (this.children != null) {
            this.children.forEach(n -> n.collectAllNodes(nodes, withLeafs));
        }
    }

    private boolean isLeaf() {
        return this.children == null || this.children.isEmpty();
    }


    public void fillModelPolicies(List<DNode> values) {
        if (this.isLeaf()) return;
        DNode node = values.stream()
                .filter(n -> this.equals(n))
                .findAny()
                .orElseThrow(MuZeroException::new);

        this.modelPolicy =  Arrays.stream(node.modelPolicy).toArray();
        if (this.children != null) {
            this.children.forEach(n -> n.fillModelPolicies(values));
        }
    }

    double expectedValueForExploiterPlayerA;
    double expectedValueForExploiterPlayerB;

    public void setExpectedValueForExploiter(OneOfTwoPlayer exploiter, double value) {
        if (exploiter == OneOfTwoPlayer.PLAYER_A) {
            this.expectedValueForExploiterPlayerA = value;
        } else {
            this.expectedValueForExploiterPlayerB = value;
        }
    }

    public double getExpectedValueForExploiter(OneOfTwoPlayer exploiter) {
        if (exploiter == OneOfTwoPlayer.PLAYER_A) {
            return this.expectedValueForExploiterPlayerA;
        } else {
            return this.expectedValueForExploiterPlayerB;
        }
    }

    public void fillExpectedValueForExploiter(OneOfTwoPlayer exploiter)  {
        if (this.isLeaf()) {
            setExpectedValueForExploiter(exploiter, - this.getValue(exploiter));
        } else {
            this.getChildren().forEach(n -> n.fillExpectedValueForExploiter(exploiter));
            double[] policy = (this.game.toPlay() == exploiter) ? this.bestResponsePolicy : this.modelPolicy;
            // expectedValue = policy * expectedValue of the children

            double expectedValue = 0;
            double[] childExpectedValues = new double[policy.length];
            this.getChildren().stream().forEach(n -> {
                int a = n.getAction();
                childExpectedValues[a] = n.getExpectedValueForExploiter(exploiter);
            });

            for (int i = 0; i < policy.length; i++) {
                    expectedValue += policy[i] * childExpectedValues[i];
            }
            setExpectedValueForExploiter(exploiter, expectedValue);

        }
    }

    public void printActions() {
        System.out.println(Arrays.toString(this.game.getEpisodeDO().getTimeSteps().stream().filter(t -> t.getAction() != null).mapToInt(t -> t.getAction()).toArray()));
    }

    public void findDifferenceBetweenModelAndBestPolicy() {
        double prod = IntStream.range(0, modelPolicy.length)
                .mapToDouble(i -> modelPolicy[i] * optimalPolicy[i])
                .sum();
        if (prod == 0d) {
            infoOnPolicyAndExploitableValue();
        }
        this.children.stream().forEach(n -> n.findDifferenceBetweenModelAndBestPolicy());
    }

    private void infoOnPolicyAndExploitableValue( ) {
        if (!this.isLeaf()  ) {
            printActions();
            System.out.println("bestExploitableValuePlayerA: " + this.bestExploitableValuePlayerA);
            System.out.println("bestExploitableValuePlayerB: " + this.bestExploitableValuePlayerB);
            System.out.println("toPlay: " + this.game.toPlay());
            System.out.println("legalActions:" + Arrays.toString(this.game.getEpisodeDO().getLastTimeStep().getLegalActions()));
            System.out.println("optimalPolicy (not knowing the modelPolicy):" + Arrays.toString(this.optimalPolicy));
            System.out.println("modelPolicy:" + Arrays.toString(this.modelPolicy));
            System.out.println("bestResponsePolicy:" + Arrays.toString(this.bestResponsePolicy));

            double max = Arrays.stream(this.modelPolicy).max().orElseThrow(MuZeroException::new);
            int a = ArrayUtils.indexOf(this.modelPolicy, max);
            DNode child = this.getChildren().stream()
                    .filter(n -> n.getAction() == a)
                    .findFirst().orElseThrow(MuZeroException::new);

            System.out.println("bestResponsePolicy on action " + a + ": " + Arrays.toString(child.bestResponsePolicy));
            System.out.println("bestExploitableValuePlayerA on child node: " + child.bestExploitableValuePlayerA);
            System.out.println("bestExploitableValuePlayerB on child node: " + child.bestExploitableValuePlayerB);

        }
    }

    public List<Integer> getActions() {
        return this.game.getEpisodeDO().getActions();
    }

    public void informOn(List<Integer> actions) {
        if (this.isLeaf()) return;
        if (!this.getActions().equals(actions)) {
            this.children.stream().forEach(n -> n.informOn(actions));
        } else {

//            System.out.println("modelPolicy: " + Arrays.toString(this.modelPolicy));
//            System.out.println("optimalPolicy: " + Arrays.toString(this.optimalPolicy));
            infoOnPolicyAndExploitableValue();
        }
    }


}
